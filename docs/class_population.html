<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hyperloop Routes: Population Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hyperloop Routes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_population-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Population Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="population_8h_source.html">population.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af036b67dfca03fa520b1e0c14a847973"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#af036b67dfca03fa520b1e0c14a847973">Population</a> (int pop_size, glm::vec4 start, glm::vec4 dest, const <a class="el" href="class_elevation_data.html">ElevationData</a> &amp;data)</td></tr>
<tr class="separator:af036b67dfca03fa520b1e0c14a847973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8cedd0f038e41746fb6084639f5616"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a4c8cedd0f038e41746fb6084639f5616">~Population</a> ()</td></tr>
<tr class="separator:a4c8cedd0f038e41746fb6084639f5616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e723c1694a1a831f46dfa454850ee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_individual.html">Individual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a28e723c1694a1a831f46dfa454850ee3">getIndividual</a> (int index)</td></tr>
<tr class="separator:a28e723c1694a1a831f46dfa454850ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa7bc5b1eaa2a67041185a2ca92cc4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a6aa7bc5b1eaa2a67041185a2ca92cc4f">step</a> (const <a class="el" href="class_pod.html">Pod</a> &amp;pod)</td></tr>
<tr class="separator:a6aa7bc5b1eaa2a67041185a2ca92cc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae5934795f9ec9ee1f6c320828d4f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a6ae5934795f9ec9ee1f6c320828d4f03">sortIndividuals</a> ()</td></tr>
<tr class="separator:a6ae5934795f9ec9ee1f6c320828d4f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d72c30398fef34f336a6b7265f04cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a86d72c30398fef34f336a6b7265f04cd">evaluateCost</a> (const <a class="el" href="class_pod.html">Pod</a> &amp;pod)</td></tr>
<tr class="separator:a86d72c30398fef34f336a6b7265f04cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1a14e15c5fe4aa14f1511aa58df967"><td class="memItemLeft" align="right" valign="top">std::vector&lt; glm::vec3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a0c1a14e15c5fe4aa14f1511aa58df967">getSolution</a> () const</td></tr>
<tr class="separator:a0c1a14e15c5fe4aa14f1511aa58df967"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a52a41d7911ed22285e95244f3f780fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a52a41d7911ed22285e95244f3f780fbb">calcGenomeSize</a> ()</td></tr>
<tr class="separator:a52a41d7911ed22285e95244f3f780fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4123726d3b7e81b3dac8fd123ec5e125"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a4123726d3b7e81b3dac8fd123ec5e125">determineEvalPoints</a> ()</td></tr>
<tr class="separator:a4123726d3b7e81b3dac8fd123ec5e125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fd879ac429afc818bcab64b4aef633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#af6fd879ac429afc818bcab64b4aef633">initParams</a> ()</td></tr>
<tr class="separator:af6fd879ac429afc818bcab64b4aef633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8f46964400234c9c8a6d503178ef2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a0f8f46964400234c9c8a6d503178ef2e">initSamplers</a> ()</td></tr>
<tr class="separator:a0f8f46964400234c9c8a6d503178ef2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1fd0a6cad512857bf09896db783d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a5b1fd0a6cad512857bf09896db783d90">initSamples</a> ()</td></tr>
<tr class="separator:a5b1fd0a6cad512857bf09896db783d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e008515bf22e73d5c4de35d4ca66659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a3e008515bf22e73d5c4de35d4ca66659">bestGuess</a> ()</td></tr>
<tr class="separator:a3e008515bf22e73d5c4de35d4ca66659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25be9ccf8ba11a1230564b3674d1c2ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a25be9ccf8ba11a1230564b3674d1c2ff">calcWeights</a> ()</td></tr>
<tr class="separator:a25be9ccf8ba11a1230564b3674d1c2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab1fb0fa49ffb149e1c7ed65ab9fce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#afab1fb0fa49ffb149e1c7ed65ab9fce6">calcInitialSigma</a> ()</td></tr>
<tr class="separator:afab1fb0fa49ffb149e1c7ed65ab9fce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7667302d37a169fb71e258bfed4bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#abd7667302d37a169fb71e258bfed4bf5">calculateStratParameters</a> ()</td></tr>
<tr class="separator:abd7667302d37a169fb71e258bfed4bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9808f1c42383f6015c672bb7b9ba030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#ae9808f1c42383f6015c672bb7b9ba030">samplePopulation</a> ()</td></tr>
<tr class="separator:ae9808f1c42383f6015c672bb7b9ba030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0561b5f1371f832ac14019dd49ce34a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a0561b5f1371f832ac14019dd49ce34a9">updateParams</a> ()</td></tr>
<tr class="separator:a0561b5f1371f832ac14019dd49ce34a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4054bc28d496288dad3230d81a98ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#ae4054bc28d496288dad3230d81a98ce8">updateMean</a> ()</td></tr>
<tr class="separator:ae4054bc28d496288dad3230d81a98ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4d26c6c88802481af7dde6dea2d58f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a4d4d26c6c88802481af7dde6dea2d58f">updatePSigma</a> ()</td></tr>
<tr class="separator:a4d4d26c6c88802481af7dde6dea2d58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9824dc385f67d72126ebf0f2fc90e9d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a9824dc385f67d72126ebf0f2fc90e9d4">updatePCovar</a> ()</td></tr>
<tr class="separator:a9824dc385f67d72126ebf0f2fc90e9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ac834d13be47e7efaf1b110a8bbae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a53ac834d13be47e7efaf1b110a8bbae9">updateCovar</a> ()</td></tr>
<tr class="separator:a53ac834d13be47e7efaf1b110a8bbae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42901c197b3073b39a52227ff48a2fc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a42901c197b3073b39a52227ff48a2fc0">updateSigma</a> ()</td></tr>
<tr class="separator:a42901c197b3073b39a52227ff48a2fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11b90b5e90c7d41126702d5292cffac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#af11b90b5e90c7d41126702d5292cffac">calcBinomialCoefficients</a> ()</td></tr>
<tr class="separator:af11b90b5e90c7d41126702d5292cffac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9f43eeeaf6bd2ec02b5063bbbbaf78b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a9f43eeeaf6bd2ec02b5063bbbbaf78b1">_pop_size</a></td></tr>
<tr class="separator:a9f43eeeaf6bd2ec02b5063bbbbaf78b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06d8208ca52ed0af4383c699ea864e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#ac06d8208ca52ed0af4383c699ea864e4">_genome_size</a></td></tr>
<tr class="separator:ac06d8208ca52ed0af4383c699ea864e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8f90d4bee983b2ab48a33dc18ef195"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a3b8f90d4bee983b2ab48a33dc18ef195">_individual_size</a></td></tr>
<tr class="separator:a3b8f90d4bee983b2ab48a33dc18ef195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0aeaa0a40d1c84026b31ac7eb0c794"><td class="memItemLeft" align="right" valign="top">glm::vec4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a4e0aeaa0a40d1c84026b31ac7eb0c794">_start</a></td></tr>
<tr class="separator:a4e0aeaa0a40d1c84026b31ac7eb0c794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa0ea5b8e48e19a77d28d0c268bb51d"><td class="memItemLeft" align="right" valign="top">glm::vec4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a7aa0ea5b8e48e19a77d28d0c268bb51d">_dest</a></td></tr>
<tr class="separator:a7aa0ea5b8e48e19a77d28d0c268bb51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a9a8defaf210633a3575fbea984d39"><td class="memItemLeft" align="right" valign="top">glm::vec4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a12a9a8defaf210633a3575fbea984d39">_direction</a></td></tr>
<tr class="separator:a12a9a8defaf210633a3575fbea984d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1f28a399453a515a73ac4f5d9cd31e"><td class="memItemLeft" align="right" valign="top">glm::vec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#aaa1f28a399453a515a73ac4f5d9cd31e">_data_size</a></td></tr>
<tr class="separator:aaa1f28a399453a515a73ac4f5d9cd31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4caa1b49c87e693c28f9bbbf5b057c"><td class="memItemLeft" align="right" valign="top">glm::vec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a4d4caa1b49c87e693c28f9bbbf5b057c">_data_origin</a></td></tr>
<tr class="separator:a4d4caa1b49c87e693c28f9bbbf5b057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24376531403464de7b208146cd3244a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#ab24376531403464de7b208146cd3244a">_num_evaluation_points</a></td></tr>
<tr class="separator:ab24376531403464de7b208146cd3244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdd0b795c6d89d3a0e34dcd3632bf81"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#abcdd0b795c6d89d3a0e34dcd3632bf81">_num_evaluation_points_1</a></td></tr>
<tr class="separator:abcdd0b795c6d89d3a0e34dcd3632bf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac36ea8d0adf5d86de7b450854020c5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; glm::vec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#aeac36ea8d0adf5d86de7b450854020c5">_individuals</a></td></tr>
<tr class="separator:aeac36ea8d0adf5d86de7b450854020c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1127116cf92d9ca43796cd834aa1b50"><td class="memItemLeft" align="right" valign="top">boost::compute::vector&lt; glm::vec4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#aa1127116cf92d9ca43796cd834aa1b50">_opencl_individuals</a></td></tr>
<tr class="separator:aa1127116cf92d9ca43796cd834aa1b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a1237b5e1fc78e9a1267fac07ad350"><td class="memItemLeft" align="right" valign="top">boost::compute::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a74a1237b5e1fc78e9a1267fac07ad350">_opencl_binomials</a></td></tr>
<tr class="separator:a74a1237b5e1fc78e9a1267fac07ad350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38141fe6b682fc55d396cc4d781d1228"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_elevation_data.html">ElevationData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a38141fe6b682fc55d396cc4d781d1228">_data</a></td></tr>
<tr class="separator:a38141fe6b682fc55d396cc4d781d1228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0141e952544cd4f4335d090a3d5b1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a0c0141e952544cd4f4335d090a3d5b1c">_mu</a></td></tr>
<tr class="separator:a0c0141e952544cd4f4335d090a3d5b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370b53f84d4c1f3057de05e66451efcc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a370b53f84d4c1f3057de05e66451efcc">_mu_weight</a></td></tr>
<tr class="separator:a370b53f84d4c1f3057de05e66451efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c921264c9e85f5dccfe1bb4a320568"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a17c921264c9e85f5dccfe1bb4a320568">_mu_weight_sqrt</a></td></tr>
<tr class="separator:a17c921264c9e85f5dccfe1bb4a320568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3086bee14a54af16b7a814081249cd7a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a3086bee14a54af16b7a814081249cd7a">_expected_value</a></td></tr>
<tr class="separator:a3086bee14a54af16b7a814081249cd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00614fb4a39e2be35f7cead3adcff6d0"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a00614fb4a39e2be35f7cead3adcff6d0">_mean</a></td></tr>
<tr class="separator:a00614fb4a39e2be35f7cead3adcff6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3198ef671dfee85ac9a91b25bd8ea4"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a6a3198ef671dfee85ac9a91b25bd8ea4">_mean_displacement</a></td></tr>
<tr class="separator:a6a3198ef671dfee85ac9a91b25bd8ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d78dbb7e414f6cf843b94b61fabb5e2"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a7d78dbb7e414f6cf843b94b61fabb5e2">_covar_matrix</a></td></tr>
<tr class="separator:a7d78dbb7e414f6cf843b94b61fabb5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe008a0b33a70380d25ab453581c4924"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#abe008a0b33a70380d25ab453581c4924">_sigma</a></td></tr>
<tr class="separator:abe008a0b33a70380d25ab453581c4924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f77c5ffb1f52964c960c7e271b4c366"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a8f77c5ffb1f52964c960c7e271b4c366">_weights</a></td></tr>
<tr class="separator:a8f77c5ffb1f52964c960c7e271b4c366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0931fa5a92840898ee33c71fba45cb16"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a0931fa5a92840898ee33c71fba45cb16">_p_covar</a></td></tr>
<tr class="separator:a0931fa5a92840898ee33c71fba45cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad661d43eda84475eee9c96db2642c36f"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#ad661d43eda84475eee9c96db2642c36f">_p_sigma</a></td></tr>
<tr class="separator:ad661d43eda84475eee9c96db2642c36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95922bb0daba8561806186c1a2c68dc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#ae95922bb0daba8561806186c1a2c68dc">_c_sigma</a></td></tr>
<tr class="separator:ae95922bb0daba8561806186c1a2c68dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de21aa44d44a2c2a151136c71adbfb0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a5de21aa44d44a2c2a151136c71adbfb0">_c_covar</a></td></tr>
<tr class="separator:a5de21aa44d44a2c2a151136c71adbfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d53c91ce41885642a6f55cfe750cc1b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a0d53c91ce41885642a6f55cfe750cc1b">_c1</a></td></tr>
<tr class="separator:a0d53c91ce41885642a6f55cfe750cc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93df09035bd07eb75a10291e932437d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#ab93df09035bd07eb75a10291e932437d">_c_mu</a></td></tr>
<tr class="separator:ab93df09035bd07eb75a10291e932437d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32c16e86ca6f39eecfff2e8edaff66e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::VectorXf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#ae32c16e86ca6f39eecfff2e8edaff66e">_samples</a></td></tr>
<tr class="separator:ae32c16e86ca6f39eecfff2e8edaff66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb0594cae875b623f916d6150781284"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_sample_generator.html">SampleGenerator</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#aedb0594cae875b623f916d6150781284">_sample_gens</a></td></tr>
<tr class="separator:aedb0594cae875b623f916d6150781284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c777f0801dc3e53f74fd535bbe141be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::VectorXf &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a9c777f0801dc3e53f74fd535bbe141be">_best_samples</a></td></tr>
<tr class="separator:a9c777f0801dc3e53f74fd535bbe141be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975d0a72c1ffd6441759bec963ad228a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_individual.html">Individual</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_population.html#a975d0a72c1ffd6441759bec963ad228a">_sorted_individuals</a></td></tr>
<tr class="separator:a975d0a72c1ffd6441759bec963ad228a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is responsible for holding individuals and breeding them. The current representation of an individual is as follows:</p>
<p>individual[0] = glm::vec4 This vector stores the cost of the individual in the X component. Other components are blank but may be used in the future.</p>
<p>individual[1] = glm::vec4 This stores the start point of the individual for more simple computation on the GPU. This is constant for every individual in the population.</p>
<p>individual[2] to individual[gene_length + 1] = glm::vec4 These are the genes, they represent X, Y and Z of the bezier control points. W is unused, however it is needed for OpenCL.</p>
<p>individual[gene_length + 2] = glm::vec4 This stores the end point of the individual for more simple computation on the GPU. This is constant for every individual in the population.</p>
<p><a class="el" href="class_population.html">Population</a> stores all of the individuals in one std::vector&lt;glm::vec4&gt; for efficient uploading to the GPU. A single individual can be accessed with the <a class="el" href="struct_individual.html">Individual</a> struct convenience. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af036b67dfca03fa520b1e0c14a847973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af036b67dfca03fa520b1e0c14a847973">&#9670;&nbsp;</a></span>Population()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Population::Population </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pop_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_elevation_data.html">ElevationData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a new population with the given parameters. Since the possible locations for the control points of the population depend on the extents of the data, it is passed in here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pop_size</td><td>The amount of individuals that should be generated.</td></tr>
    <tr><td class="paramname">start</td><td>The start location of the path. X, Y and Z are measured in meters.</td></tr>
    <tr><td class="paramname">dest</td><td>The destination of the path. X, Y and Z are measured in meters.</td></tr>
    <tr><td class="paramname">data</td><td>The elevation data that this population is path-finding on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c8cedd0f038e41746fb6084639f5616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8cedd0f038e41746fb6084639f5616">&#9670;&nbsp;</a></span>~Population()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Population::~Population </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple destructor to delete heap allocated things </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3e008515bf22e73d5c4de35d4ca66659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e008515bf22e73d5c4de35d4ca66659">&#9670;&nbsp;</a></span>bestGuess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::bestGuess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When CMA-ES first starts, the mean is supposed to be the "best guess" for the desired result. In our case, our best is a straight line from the starting position to the destination. The mean vector generated by this function is a ordered distribution of linear steps toward the destination. </p>

</div>
</div>
<a id="af11b90b5e90c7d41126702d5292cffac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11b90b5e90c7d41126702d5292cffac">&#9670;&nbsp;</a></span>calcBinomialCoefficients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::calcBinomialCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To evaluate the bezier curve, binomial coefficients are required. These need factorials, so it would be slow to compute them. Instead we do it once, offline because all paths have the same degree. This computes those coefficients. </p>

</div>
</div>
<a id="a52a41d7911ed22285e95244f3f780fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a41d7911ed22285e95244f3f780fbb">&#9670;&nbsp;</a></span>calcGenomeSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::calcGenomeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function calculates the size of the genome. This is based off the length of the route that this population represent and has a square root relationship. </p>

</div>
</div>
<a id="afab1fb0fa49ffb149e1c7ed65ab9fce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab1fb0fa49ffb149e1c7ed65ab9fce6">&#9670;&nbsp;</a></span>calcInitialSigma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::calcInitialSigma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sigma represents how spread out the distribution will be, in other words the step size. Because the sample space in Z is smaller than X and Y, sigma should reflect that initially </p>

</div>
</div>
<a id="abd7667302d37a169fb71e258bfed4bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7667302d37a169fb71e258bfed4bf5">&#9670;&nbsp;</a></span>calculateStratParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::calculateStratParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function calculates some of the evolutionary parameters that remain constant </p>

</div>
</div>
<a id="a25be9ccf8ba11a1230564b3674d1c2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25be9ccf8ba11a1230564b3674d1c2ff">&#9670;&nbsp;</a></span>calcWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::calcWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When we recalculate the mean vector from the best solutions, we do a weighting. This function calculates the weights for mew (the selected population) once, as it remains constant. </p>

</div>
</div>
<a id="a4123726d3b7e81b3dac8fd123ec5e125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4123726d3b7e81b3dac8fd123ec5e125">&#9670;&nbsp;</a></span>determineEvalPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::determineEvalPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When the GPU kernel to evaluate the cost is run, the bezier curve is sampled at discrete intervals. For longer routes this needs to be higher so we have a rougly consistant meter-bezier sample. This function determines the number of points to use. </p>

</div>
</div>
<a id="a86d72c30398fef34f336a6b7265f04cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d72c30398fef34f336a6b7265f04cd">&#9670;&nbsp;</a></span>evaluateCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Population::evaluateCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pod.html">Pod</a> &amp;&#160;</td>
          <td class="paramname"><em>pod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is what makes the genetic algorithm work. For every individual a cost is evaluated. This represents how good their genome is as a solution. This function performs this, using OpenCL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pod</td><td>The pod object containing the specs of the pod. Right now just uses max speed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28e723c1694a1a831f46dfa454850ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e723c1694a1a831f46dfa454850ee3">&#9670;&nbsp;</a></span>getIndividual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_individual.html">Individual</a> Population::getIndividual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves an individual from the population. This assumes that the population data has already been copied back to the CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the individual in the population that is desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_individual.html">Individual</a> struct; a convenience reference to the data in _individuals. </dd></dl>

</div>
</div>
<a id="a0c1a14e15c5fe4aa14f1511aa58df967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1a14e15c5fe4aa14f1511aa58df967">&#9670;&nbsp;</a></span>getSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; glm::vec3 &gt; Population::getSolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the computed solution to the route (the mean).</p>
<dl class="section return"><dt>Returns</dt><dd>The control points of the completed route containing the start and destination. </dd></dl>

</div>
</div>
<a id="af6fd879ac429afc818bcab64b4aef633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fd879ac429afc818bcab64b4aef633">&#9670;&nbsp;</a></span>initParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::initParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function initializes the parameters for CMA-ES. Parameters include the covariance matrix, the mean, the evolution path and the step size. </p>

</div>
</div>
<a id="a0f8f46964400234c9c8a6d503178ef2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8f46964400234c9c8a6d503178ef2e">&#9670;&nbsp;</a></span>initSamplers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::initSamplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Becasue sampling from the multivariate normal distribution is so slow, we use some multithreading tricks to speed it up. Firstly, since all MVND's require samples from the standard normal distribution we create objects that generate these samples in another thread. Secondly we split the population up into NUM_SAMPLE_THREADS so that we can sample multiple individuals concurrently. This function creates the prerequisites for this. </p>

</div>
</div>
<a id="a5b1fd0a6cad512857bf09896db783d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1fd0a6cad512857bf09896db783d90">&#9670;&nbsp;</a></span>initSamples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::initSamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The samples vector is created once here. All samples that are done will overwrite the last ones to avoid memory copying. All elements in the vector are also initialized here. </p>

</div>
</div>
<a id="ae9808f1c42383f6015c672bb7b9ba030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9808f1c42383f6015c672bb7b9ba030">&#9670;&nbsp;</a></span>samplePopulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::samplePopulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This samples an entirely new population. We use the calculate / starting covariance matrix, the best solution (m) and the step size. A multivariate normal distribution is temporarily constructed from these parameters and then the population is sampled from it. </p>

</div>
</div>
<a id="a6ae5934795f9ec9ee1f6c320828d4f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae5934795f9ec9ee1f6c320828d4f03">&#9670;&nbsp;</a></span>sortIndividuals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Population::sortIndividuals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sorts the individuals in ascending order based on the cost. _individuals[0] becomes the most fit individual. Currently this is done on the CPU, which is not optimal, but it is simpler. </p>

</div>
</div>
<a id="a6aa7bc5b1eaa2a67041185a2ca92cc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa7bc5b1eaa2a67041185a2ca92cc4f">&#9670;&nbsp;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Population::step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pod.html">Pod</a> &amp;&#160;</td>
          <td class="paramname"><em>pod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simulates the population for an entire generation. The steps are as follows:</p><ul>
<li>Rank the current population</li>
<li>Update the CMA-ES params</li>
<li>Sample a new population</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pod</td><td>The pod object containing the specs of the pod. Right now just uses max speed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53ac834d13be47e7efaf1b110a8bbae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ac834d13be47e7efaf1b110a8bbae9">&#9670;&nbsp;</a></span>updateCovar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::updateCovar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the covariance matrix for the population using path length control. This adapts the relationship between each of the points to converge on the best solution. </p>

</div>
</div>
<a id="ae4054bc28d496288dad3230d81a98ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4054bc28d496288dad3230d81a98ce8">&#9670;&nbsp;</a></span>updateMean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::updateMean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function re-calculates the mean vector of the population. The only individuals that are used in this calculation are the _mu most fit ones. Each individual is weighted by its corresponding _weights value based on its index. </p>

</div>
</div>
<a id="a0561b5f1371f832ac14019dd49ce34a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0561b5f1371f832ac14019dd49ce34a9">&#9670;&nbsp;</a></span>updateParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::updateParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function updates the parameters of the distribution including the covariance matrix and mean vector based on the current population. We use "," selection, meaning we only sample from the current generation. </p>

</div>
</div>
<a id="a9824dc385f67d72126ebf0f2fc90e9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9824dc385f67d72126ebf0f2fc90e9d4">&#9670;&nbsp;</a></span>updatePCovar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::updatePCovar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function updates the evolutionary path for the covariance matrix. We do this by using mostly the same factors as the sigma path but we also use the indicator function. </p>

</div>
</div>
<a id="a4d4d26c6c88802481af7dde6dea2d58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4d26c6c88802481af7dde6dea2d58f">&#9670;&nbsp;</a></span>updatePSigma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::updatePSigma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function updates the evolutionary path for sigma. We do this by using the covariance matrix and some evolutionary stratagy params. </p>

</div>
</div>
<a id="a42901c197b3073b39a52227ff48a2fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42901c197b3073b39a52227ff48a2fc0">&#9670;&nbsp;</a></span>updateSigma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Population::updateSigma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the step size for the population using path length control. This adapts the step size to quickly converge on a solution. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9c777f0801dc3e53f74fd535bbe141be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c777f0801dc3e53f74fd535bbe141be">&#9670;&nbsp;</a></span>_best_samples</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::VectorXf&gt; Population::_best_samples</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The _mu best multinormal samples from the population </p>

</div>
</div>
<a id="a0d53c91ce41885642a6f55cfe750cc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d53c91ce41885642a6f55cfe750cc1b">&#9670;&nbsp;</a></span>_c1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Population::_c1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The learning rate for the rank 1 update of the the covariance matrix </p>

</div>
</div>
<a id="a5de21aa44d44a2c2a151136c71adbfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de21aa44d44a2c2a151136c71adbfb0">&#9670;&nbsp;</a></span>_c_covar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Population::_c_covar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The inverse of _c_covar is the the backward time horizon for the evolution path for the covariance matrix. </p>

</div>
</div>
<a id="ab93df09035bd07eb75a10291e932437d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93df09035bd07eb75a10291e932437d">&#9670;&nbsp;</a></span>_c_mu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Population::_c_mu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The learning rate for the rank mu update of the covariance matrix </p>

</div>
</div>
<a id="ae95922bb0daba8561806186c1a2c68dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95922bb0daba8561806186c1a2c68dc">&#9670;&nbsp;</a></span>_c_sigma</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Population::_c_sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The inverse of _c_sigma is the the backward time horizon for the evolution path for the step size. </p>

</div>
</div>
<a id="a7d78dbb7e414f6cf843b94b61fabb5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d78dbb7e414f6cf843b94b61fabb5e2">&#9670;&nbsp;</a></span>_covar_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXf Population::_covar_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The covariance matrix of the population. This contains the information about how the multivariate normal distribution is shaped. This is a _genome_size * 3 X _genome_size * 3 matrix, 3 components for each point in the bezier curve (X, Y, Z). </p>

</div>
</div>
<a id="a38141fe6b682fc55d396cc4d781d1228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38141fe6b682fc55d396cc4d781d1228">&#9670;&nbsp;</a></span>_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_elevation_data.html">ElevationData</a>&amp; Population::_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The reference to the elevation data that this population operates on. Its stored as const because nothing should ever be done to the data except reading. </p>

</div>
</div>
<a id="a4d4caa1b49c87e693c28f9bbbf5b057c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4caa1b49c87e693c28f9bbbf5b057c">&#9670;&nbsp;</a></span>_data_origin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec2 Population::_data_origin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The size of the data in meters </p>

</div>
</div>
<a id="aaa1f28a399453a515a73ac4f5d9cd31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1f28a399453a515a73ac4f5d9cd31e">&#9670;&nbsp;</a></span>_data_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec2 Population::_data_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The origin of the data in meters relative to the database absolute origin </p>

</div>
</div>
<a id="a7aa0ea5b8e48e19a77d28d0c268bb51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa0ea5b8e48e19a77d28d0c268bb51d">&#9670;&nbsp;</a></span>_dest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec4 Population::_dest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The ending position of the path that this population is trying to "solve" </p>

</div>
</div>
<a id="a12a9a8defaf210633a3575fbea984d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a9a8defaf210633a3575fbea984d39">&#9670;&nbsp;</a></span>_direction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec4 Population::_direction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The direction vector of the path that this population is built for. Measured in meters. </p>

</div>
</div>
<a id="a3086bee14a54af16b7a814081249cd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3086bee14a54af16b7a814081249cd7a">&#9670;&nbsp;</a></span>_expected_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Population::_expected_value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The expectedc value of the standard normal distribution. We use this to determine if we should shrink or grow sigma </p>

</div>
</div>
<a id="a39b2e8896cfa6a1c5e40a8db307c445f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b2e8896cfa6a1c5e40a8db307c445f">&#9670;&nbsp;</a></span>_fitness_over_generations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; Population::_fitness_over_generations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This vector contains the best fitness values of each generation. Every time <a class="el" href="class_population.html#a6aa7bc5b1eaa2a67041185a2ca92cc4f">step()</a> is called, the value of the cost function for the fittest individual is saved </p>

</div>
</div>
<a id="ac06d8208ca52ed0af4383c699ea864e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06d8208ca52ed0af4383c699ea864e4">&#9670;&nbsp;</a></span>_genome_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Population::_genome_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of "genes" (bezier curve control points) that each individual should have. </p>

</div>
</div>
<a id="a3b8f90d4bee983b2ab48a33dc18ef195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8f90d4bee983b2ab48a33dc18ef195">&#9670;&nbsp;</a></span>_individual_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Population::_individual_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This number represents the size of glm::vec4s that an individual is. This includes the genome size, the header and the start and destination </p>

</div>
</div>
<a id="aeac36ea8d0adf5d86de7b450854020c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac36ea8d0adf5d86de7b450854020c5">&#9670;&nbsp;</a></span>_individuals</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;glm::vec4&gt; Population::_individuals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The CPU storage of the individuals. </p>

</div>
</div>
<a id="a00614fb4a39e2be35f7cead3adcff6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00614fb4a39e2be35f7cead3adcff6d0">&#9670;&nbsp;</a></span>_mean</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXf Population::_mean</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This represents the current mean vector of the population. In other words, this is the favorite solution the the population. The vector is legnth _genome_size * 3, 3 components for each point in the bezier curve (X, Y, Z). </p>

</div>
</div>
<a id="a6a3198ef671dfee85ac9a91b25bd8ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3198ef671dfee85ac9a91b25bd8ea4">&#9670;&nbsp;</a></span>_mean_displacement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXf Population::_mean_displacement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The difference between the new mean and the last mean divided by the step size </p>

</div>
</div>
<a id="a0c0141e952544cd4f4335d090a3d5b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0141e952544cd4f4335d090a3d5b1c">&#9670;&nbsp;</a></span>_mu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Population::_mu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of individuals that are selected from each generation that are the best solutions </p>

</div>
</div>
<a id="a370b53f84d4c1f3057de05e66451efcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370b53f84d4c1f3057de05e66451efcc">&#9670;&nbsp;</a></span>_mu_weight</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Population::_mu_weight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the sum of 1/_weights^2 </p>

</div>
</div>
<a id="a17c921264c9e85f5dccfe1bb4a320568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c921264c9e85f5dccfe1bb4a320568">&#9670;&nbsp;</a></span>_mu_weight_sqrt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Population::_mu_weight_sqrt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The square root of _mu_weight </p>

</div>
</div>
<a id="ab24376531403464de7b208146cd3244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24376531403464de7b208146cd3244a">&#9670;&nbsp;</a></span>_num_evaluation_points</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Population::_num_evaluation_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Since the cost algorithm uses sampling we need to know how many samples to take. For one dataset this is a trivial task. However some routes may span multiple datasets and therefore a calculation needs to be performed to figure out how may samples should be taken. </p>

</div>
</div>
<a id="abcdd0b795c6d89d3a0e34dcd3632bf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdd0b795c6d89d3a0e34dcd3632bf81">&#9670;&nbsp;</a></span>_num_evaluation_points_1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Population::_num_evaluation_points_1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>_num_evaluation_points - 1. This is a float because it is used for division in the cost function </p>

</div>
</div>
<a id="a74a1237b5e1fc78e9a1267fac07ad350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a1237b5e1fc78e9a1267fac07ad350">&#9670;&nbsp;</a></span>_opencl_binomials</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::vector&lt;int&gt; Population::_opencl_binomials</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To evaluate the bezier curve, binomial coefficients are required. These need factorials, so it would be slow to compute them. Instead we do it once, offline because all paths have the same degree. This stores the compute coefficients on the GPU. </p>

</div>
</div>
<a id="aa1127116cf92d9ca43796cd834aa1b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1127116cf92d9ca43796cd834aa1b50">&#9670;&nbsp;</a></span>_opencl_individuals</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::vector&lt;glm::vec4&gt; Population::_opencl_individuals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The GPU uploaded version of the individual data </p>

</div>
</div>
<a id="a0931fa5a92840898ee33c71fba45cb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0931fa5a92840898ee33c71fba45cb16">&#9670;&nbsp;</a></span>_p_covar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXf Population::_p_covar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The evolution path for the covariance matrix. This is used to adapt the covariance matrix each step so that successful search steps vary closer to the favorable solution. </p>

</div>
</div>
<a id="ad661d43eda84475eee9c96db2642c36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad661d43eda84475eee9c96db2642c36f">&#9670;&nbsp;</a></span>_p_sigma</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXf Population::_p_sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The evolution path for the step size (sigma). This is used to adapt the step size each step so that successful do not prematurely converge. </p>

</div>
</div>
<a id="a9f43eeeaf6bd2ec02b5063bbbbaf78b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f43eeeaf6bd2ec02b5063bbbbaf78b1">&#9670;&nbsp;</a></span>_pop_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Population::_pop_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of individuals that should be in this population </p>

</div>
</div>
<a id="aedb0594cae875b623f916d6150781284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb0594cae875b623f916d6150781284">&#9670;&nbsp;</a></span>_sample_gens</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_sample_generator.html">SampleGenerator</a>*&gt; Population::_sample_gens</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Several multithreaded standard normal sample generator to speed up population sampling </p>

</div>
</div>
<a id="ae32c16e86ca6f39eecfff2e8edaff66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32c16e86ca6f39eecfff2e8edaff66e">&#9670;&nbsp;</a></span>_samples</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::VectorXf&gt; Population::_samples</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The samples from the distribution minus the mean. We separate this from the completed, evalulatable population to decrease the chance of numerical error because we are dealing with large numbers. </p>

</div>
</div>
<a id="abe008a0b33a70380d25ab453581c4924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe008a0b33a70380d25ab453581c4924">&#9670;&nbsp;</a></span>_sigma</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXf Population::_sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current step size. This is how far the next generation will move. The vector is length _genome_size * 3, 3 components for each point in the bezier curve (X, Y, Z). </p>

</div>
</div>
<a id="a975d0a72c1ffd6441759bec963ad228a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975d0a72c1ffd6441759bec963ad228a">&#9670;&nbsp;</a></span>_sorted_individuals</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_individual.html">Individual</a>&gt; Population::_sorted_individuals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The vector that is used to sort the individuals. We keep this around to avoid allocating every time we sort </p>

</div>
</div>
<a id="a4e0aeaa0a40d1c84026b31ac7eb0c794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0aeaa0a40d1c84026b31ac7eb0c794">&#9670;&nbsp;</a></span>_start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec4 Population::_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The starting position of the path that this population is trying to "solve" </p>

</div>
</div>
<a id="a8f77c5ffb1f52964c960c7e271b4c366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f77c5ffb1f52964c960c7e271b4c366">&#9670;&nbsp;</a></span>_weights</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; Population::_weights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When we recalculate the mean vector from the best solutions, we do a weighting. This vector stores these weights where _weights[0] is the highest weight, meant for the best solution. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/routes-lib/genetics/<a class="el" href="population_8h_source.html">population.h</a></li>
<li>src/routes-lib/genetics/<a class="el" href="population_8cpp.html">population.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
